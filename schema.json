{
	"$schema": "https://json-schema.org/draft/2020-12/schema",
	"$id": "https://schemas.dinwoodie.org/asm.json",
	"title": "Asmodeus task list",
	"description": "TODO",

	"allOf": [
		{"$ref": "#/$defs/task"},
		{"$ref": "#/$defs/check_placeholder_descendent_states"}
	],

	"$defs": {
		"python": {
			"datetime": {
				"timedelta": {
					"description": "A Python datetime.timedelta object.",
					"$comment": "Automated tools SHOULD either (a) normalise this object in the same way as the Python datetime library, or (b) perform no normalization.",
					"type": "object",
					"properties": {
						"weeks": {"type": "integer"},
						"days": {"type": "integer"},
						"hours": {"type": "integer"},
						"minutes": {"type": "integer"},
						"seconds": {"type": "integer"},
						"milliseconds": {"type": "integer"},
						"microseconds": {"type": "integer"}
					},
					"unevaluatedProperties": false
				},
				"_date_datetime_common": {
					"$comment": "This object defines the common required fields for both datetime.date and datetime.datetime objects to avoid repetition.  We can't just do this in datetime.date then reference that from datetime.datetime, as both datetime.date and datetime.datetime want to set unevaluatedProperties to false.",
					"type": "object",
					"properties": {
						"year": {
							"type": "integer",
							"minimum": 1,
							"maximum": 9999
						},
						"month": {
							"type": "integer",
							"minimum": 1,
							"maximum": 12
						},
						"day": {
							"$comment": "We could put in some fancier validation here, to ensure that the day is valid for the given month and year, but that seems like vast overkill.",
							"type": "integer",
							"minimum": 1,
							"maximum": 31
						}
					},
					"required": [
						"year",
						"month",
						"day"
					]
				},
				"date": {
					"$ref": "#/$defs/python/datetime/_date_datetime_common",
					"unevaluatedProperties": false
				},
				"datetime": {
					"type": "object",
					"$ref": "#/$defs/python/datetime/_date_datetime_common",
					"properties": {
						"hour": {
							"type": "integer",
							"minimum": 0,
							"maximum": 23
						},
						"minute": {
							"type": "integer",
							"minimum": 0,
							"maximum": 59
						},
						"second": {
							"type": "integer",
							"minimum": 0,
							"maximum": 0
						},
						"microsecond": {
							"type": "integer",
							"minimum": 0,
							"maximum": 999999
						},
						"tzinfo": {
							"$comment": "This is a stricter definition than the one that the datetime module uses, but implementing the datetime module's version seems unnecessary.",
							"$ref": "#/$defs/python/datetime/timezone"
						},
						"fold": {
							"enum": [0, 1]
						}
					},
					"unevaluatedProperties": false
				},
				"timezone": {
					"type": "object",
					"properties": {
						"offset": {
							"$ref": "#/$defs/python/datetime/timedelta"
						},
						"name": {
							"type": "string"
						}
					},
					"required": ["offset"],
					"unevaluatedProperties": false
				}
			},
			"dateutil": {
				"relativedelta": {
					"relativedelta": {
						"type": "object",
						"$comment": "Automated tools MAY normalize the version specified with two datetime objects to the explicit form, normalize integer weekdays to the referenced version, and convert specified weeks, yearday and nlyeaday values in the same way that the Python dateutil does.",
						"anyOf": [
							{
								"properties": {
									"years": {
										"type": "integer",
										"minimum": -9999,
										"maximum": 9999
									},
									"months": {
										"type": "integer",
										"minimum": -12,
										"maximum": 12
									},
									"days": {"type": "integer"},
									"leapdays": {"type": "integer"},
									"weeks": {"type": "integer"},
									"hours": {"type": "integer"},
									"minutes": {"type": "integer"},
									"seconds": {"type": "integer"},
									"microseconds": {"type": "integer"},
									"year": {
										"type": "integer",
										"minimum": 1,
										"maximum": 9999
									},
									"month": {
										"type": "integer",
										"minimum": 1,
										"maximum": 12
									},
									"day": {
										"type": "integer",
										"minimum": 1,
										"maximum": 31
									},
									"weekday": {
										"anyOf": [
											{"$ref": "#/$defs/python/dateutil/relativedelta/weekday"},
											{
												"type": "integer",
												"minimum": 0,
												"maximum": 6
											}
										]
									},
									"yearday": {"type": "integer"},
									"nlyearday": {"type": "integer"},
									"hour": {
										"type": "integer",
										"minimum": 0,
										"maximum": 23
									},
									"minute": {
										"type": "integer",
										"minimum": 0,
										"maximum": 59
									},
									"second": {
										"type": "integer",
										"minimum": 0,
										"maximum": 59
									},
									"microsecond": {
										"type": "integer",
										"minimum": 0,
										"maximum": 999999
									}
								},
								"unevaluatedProperties": false
							},
							{
								"patternProperties": {
									"^dt[12]$": {
										"$ref": "#/$defs/python/datetime/datetime",
										"required": ["tzinfo"]
									}
								},
								"required": ["dt1", "dt2"],
								"unevaluatedProperties": false

							},
							{
								"patternProperties": {
									"^dt[12]$": {
										"$ref": "#/$defs/python/datetime/datetime",
										"properties": {
											"tzinfo": false
										}
									}
								},
								"required": ["dt1", "dt2"],
								"unevaluatedProperties": false

							}
						]
					},
					"weekday": {
						"$comment": "Store as a string like that which Python's repr produces.  TODO add an alternative for storing in a more structured fashion.",
						"type": "string",
						"pattern": "^(MO|TU|WE|TH|FR|SA|SU)(\\([+-]?[1-9][0-9]*\\))?$"
					}
				},
				"rrule": {
					"$comment": "TODO",
					"allOf": [false]
				}
			}
		},
		"date": {
			"description": "Either a date object or a date string.",
			"$comment": "Automated tools MAY convert the Python object to an ISO-format string for simplicity.",
			"anyOf": [
				{
					"type": "string",
					"format": "date"
				},
				{"$ref": "#/$defs/python/datetime/date"}
			]
		},
		"datetime": {
			"description": "Something that can be treated as a datetime object.",
			"$comment": "Automated tools SHOULD (a) treat datetimes without a timezone as being in the system local timezone, (c) store datetimes with an explicit UTC offset, (d) store datetimes with the UTC offset they were originally specified with.  Automated tools MAY convert the python object to a string.",
			"anyOf": [
				{
					"type": "string",
					"format": "date-time"
				},
				{"$ref": "#/$defs/python/datetime.datetime"}
			]
		},
		"task": {
			"type": "object",

			"properties": {
				"title": {
					"description": "Title of the task.",
					"type": "string"
				},
				"id": {
					"description": "Unique ID for the task.",
					"$comment": "Automated tools SHOULD populate this if it isn't already specified, and MAY use any valid mechanism for doing so.",
					"type": "string",
					"format": "uuid"
				},
				"state": {
					"description": "The state the task is in.  Defaults to 'todo'.",
					"$comment": "If this is unspecified and either (a) not root task or (b) there are descendent tasks that have this value set to 'placeholder', automated tools SHOULD populate this as 'placeholder'.  If this is the root task, automated tools MUST treat it as 'placeholder', SHOULD NOT populate it and SHOULD remove it if it is already populated.  Otherwise if this is unspecified, automated tools SHOULD assume it is 'todo'.  If this is explicitly 'todo', automated tools MAY remove the explicit specification; if this is implicitly 'todo', automated tools MAY explicitly set the value.  If automated tools are changing the value between implicit and explicit 'todo' specifications, they SHOULD provide a configuration option to at least disable this behaviour, to avoid unnecessary churn for users using multiple tools.",
					"enum": [
						"placeholder",
						"todo",
						"done",
						"dropped"
					]
				},

				"created": {
					"description": "The date and time the task was created.",
					"$comment": "Automated tools SHOULD set this if it is unset to any reasonable value, typically either the current time or the last modification time if the data is read from a file.",
					"$ref": "#/$defs/datetime"
				},
				"due": {
					"description": "The date or date and time when the task is due.  Dates without a time are assumed to be due by the end of that day.",
					"type": "string",
					"anyOf": [
						{"format": "date-time"},
						{"format": "date"}
					]
				},

				"children": {
					"description": "List of subtasks of this task.",
					"$comment": "Automated tools MAY remove this element if it is empty.",
					"type": "array",
					"items": {"$ref": "#/$defs/task"}
				},

				"requires": {
					"description": "List of task IDs that must be completed before this task.  TODO This should handle a single item being specified as a string rather than a singleton list.",
					"type": "array",
					"items": {
						"type": "string",
						"format": "uuid"
					}
				},
				"blocks": {
					"description": "List of task IDs that cannot be completed before this task.  TODO This should handle a single item being specified as a string rather than a singleton list.",
					"$comment": "Automated tools MAY normalise tasks by removing this property and instead populating the 'requires' properties on the referenced tasks.",
					"type": "array",
					"items": {
						"type": "string",
						"format": "uuid"
					}
				},

				"notes": {
					"description": "Notes attached to the task.",
					"$comment": "Automated tools SHOULD NOT make any assumptions about the content of this property.",
					"type": "string"
				},

				"contexts": {
					"description": "The context or contexts in which this task can be completed.",
					"$comment": "If this is a string, automated tools MAY convert it to a singleton list.  If this is a list with duplicate values, automated tools MAY remove the duplicates.  Automated tools MAY reorder the list.",
					"anyOf": [
						{"type": "string"},
						{
							"type": "array",
							"items": {"type": "string"}
						}
					]
				},

				"base_urgency": {
					"description": "The starting urgency score for the task.",
					"type": "number"
				},
				"age_urgency_factor": {
					"description": "The amount the urgency increases each day.",
					"type": "number"
				},
				"age_urgency_max": {
					"description": "The maximum amount the urgency can be increased by due to task age.",
					"type": "number"
				},
				"blocking_any_urgency_factor": {
					"description": "The amount the urgency is increased by if this task is a blocking task.",
					"type": "number"
				},
				"blocking_each_urgency_factor": {
					"description": "The amount the urgency is increased by for each task this task is blocking.",
					"type": "number"
				},
				"blocking_each_urgency_max": {
					"description": "The maximum amount the urgency can be increased by because of blocking multiple tasks.",
					"type": "number"
				}
			},


			"unevaluatedProperties": false
		},
		"check_placeholder_descendent_states": {
			"properties": {
				"state": {"const": "placeholder"},
				"children": {
					"items": {
						"anyOf": [
							{"$ref": "#/$defs/check_placeholder_descendent_states"},
							{"$ref": "#/$defs/check_todo_descendent_states"},
							{"$ref": "#/$defs/check_done_dropped_descendent_states"}
						]
					}
				}
			},
			"required": ["children"]
		},
		"check_todo_descendent_states": {
			"properties": {
				"state": {"const": "todo"},
				"children": {
					"items": {
						"anyOf": [
							{"$ref": "#/$defs/check_todo_descendent_states"},
							{"$ref": "#/$defs/check_done_dropped_descendent_states"}
						]
					}
				}
			}
		},
		"check_done_dropped_descendent_states": {
			"properties": {
				"state": {"enum": ["done", "dropped"]},
				"children": {
					"items": {"$ref": "#/$defs/check_done_dropped_descendent_states"}
				}
			},
			"required": ["state"]
		}
	}
}
